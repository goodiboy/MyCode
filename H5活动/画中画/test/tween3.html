<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width" user-scalable="0">
    <style>
        *{
            margin:0;
            padding:0;
        }
        html,body{
            height: 100%;
            overflow: hidden;
        }
        #canvas{
            height: 100%;
            /*background: pink;*/
        }
        .btn{
            position: absolute;
            z-index: 2;
            width:30%;
            left:40%;
            bottom:5%;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="750" height="1206"></canvas>
    <img src="btn.png" class="btn" alt="">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script>

    // requestAnimationFrame兼容写法
    window.requestAnimationFrame= (function(){
        return window.requestAnimationFrame ||
         window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame ||
          function(callback){
              window.setTimeout(callback, 17);
          }
    })();
    window.cancelAnimationFrame = (function(){
        return window.cancelAnimationFrame ||
        window.webkitCancelAnimationFrame ||
        window.mozCancelAnimationFrame ||
        function(id){
            window.clearTimeout(id);
        }
    })();

    var easeIn = function(t, b, c, d) {
          return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
    }
    

    var can = document.querySelector('#canvas');
    var img1 = new Image();
    img1.src = '2.jpg';
    // var img2 = new Image();
    // img2.src = '2.jpg';
    
    var ctx = can.getContext('2d');
    img1.onload = function(){
        ctx.drawImage(img1,0,0,750,1206); 
    }
    
    


   
    var drawScale = function (data) {
        this.img1 = new Image();
        this.img1.src = data.imgUrl1;

        this.img2 = new Image();
        this.img2.src = data.imgUrl2;

        // 保存图一原始的位置和宽高属性
        this.originalX = data.sx;   
        this.originalY = data.sy;
        this.originalW = data.sw;
        this.originalH = data.sh;

        // 缩放底图(图一)目标点的位置和宽高属性
        this.sx = data.sx;  // (图一)目标点左侧的距离
        this.sy = data.sy;  // (图一)目标点顶部的距离
        this.sw = data.sw;  // (图一)目标点的宽度
        this.sh = data.sh;  // (图一)目标点的高度

        // 保存图二原始的位置和宽高属性
        this.originalX2 = data.sx2; 
        this.originalY2 = data.sy2;
        this.originalW2 = data.sw2;
        this.originalH2 = data.sh2;


        // 缩放上面（图二）的位置和属性
        this.sx2 = data.sx2;    // (图二)目标点左侧的距离
        this.sy2 = data.sy2;    // (图二)目标点顶部的距离
        this.sw2 = data.sw2;    // (图二)目标点的宽度
        this.sh2 = data.sh2;    // (图二)目标点的高度

        // 求出最新的目标点宽度和原始的比例,用于同步缩放图二
        this.scaW = this.originalX / this.sw;

        // 求出最新的目标点高度度和原始的比例,用于同步缩放图二
        this.scaH = this.originalH / this.sh;

        // 图一目标点距离底部的距离
        var disBottom = this.sh2 - this.sy - this.sh;

        // 图一目标点距离右侧的距离
        var disRight = this.sw2 - this.sx - this.sw;

        // 图一目标点距离底部和距离顶部的比例
        this.scaleHeight = disBottom / this.sy;

        // 图一目标点距离右边和距离左边的比例
        this.scaleWidth = disRight / this.sx;


        // 计算图一目标点右侧占整宽度（减去目标点的宽度）的百分比
        this.scaleRigth = disRight / (this.sw2  - this.sw );

        // 计算图一目标点距离底部占整总高度（减去目标点的宽度）的百分比
        this.scaleBottom = disBottom / (this.sh2  - this.sh );

        // 绘图
        this.draw = function (){
            // 绘制图一
           ctx.drawImage(this.img2,this.sx,this.sy,this.sw,this.sh,0,0,can.width,can.height); 
            // 绘制图二
           ctx.drawImage(this.img1,this.sx2,this.sy2,this.sw2,this.sh2); 
        }

    }

    /**
     * 前进
     * @vx  运动函数返回来的x方向位置值
     * @vy  运动函数返回来的y方向位置值
     */
    var drawGo = function (vx,vy) {

        // 如果x轴没有到左上角0 0的位置就进行重绘
        if (this.sx <= 0){
            this.sx = 0;
            this.sw = can.width;
        }else{

            // 最新x轴的位置 = 用原始的x轴位置减去x轴的偏移值
            this.sx = this.originalX - vx;

            // 最新目标图宽度 = 原始大小 + x轴的偏移值 + 右侧长度（用右侧与左侧的比例 * x抽偏移量）
            this.sw = this.originalW + vx + this.scaleWidth*vx;

            // 求出最新的目标点宽度和原始的比例,用于同步缩放图二
            this.scaW = this.sw / this.originalW;

            // 图二的最新宽度 = 原始宽度 / 图一宽度放大的比例 
            this.sw2 = this.originalW2 / this.scaW;

            // 图二最新x轴偏移位置 = 原始的宽度 - 图二最新的宽度 - （原始-最新的剩余宽度）* 目标点右侧和左侧的比例
            this.sx2 = this.originalW2 - this.sw2 - (this.originalW2 - this.sw2)*this.scaleRigth ;
            // console.log( this.sw2,this.sw,this.scaW);
            console.log(this.sx, this.sx2);
           
        }

        if (this.sy <= 0){
            this.sy = 0;
            this.sh = can.height;
        }else{
            // 最新y轴的位置 = 用原始的y轴位置减去x轴的偏移值
            this.sy = this.originalY - vy;

            // 最新目标图高度 = 原始大小 + y轴的偏移值 + 距离底部长度（用底部与顶部距离的比例 * y抽偏移量）
            this.sh = this.originalH + vy + this.scaleHeight * vy;

            // 求出最新的目标点高度和原始的比例,用于同步缩放图二
            this.scaH = this.sh / this.originalH;

            
            // 图二的最新高度 = 原始高度 / 图一高度放大的比例 
            this.sh2 = this.originalH2 / this.scaH;

            // 图二最新y轴偏移位置 = 原始的高度 - 图二最新的高度 - （原始-最新的剩余高度）* 目标点底部和顶部的比例
            this.sy2 = this.originalH2 - this.sh2 - (this.originalH2 - this.sh2) * this.scaleBottom;
        }



        // console.log('w: '+this.sw);
        // console.log('h: '+this.sh);
        // console.log('x: '+this.sx);
        // console.log('y: '+this.sy);

        // console.log('w2: '+this.sw2);
        // console.log('h2: '+this.sh2);
        // console.log('x2: '+this.sx2);
        // console.log('y2: '+this.sy2);
        this.draw();
    }

    /**
     * 后退
     * @vx  运动函数返回来的x方向位置值
     * @vy  运动函数返回来的y方向位置值
     */
    var drawBack = function (vx,vy) {


        // 如果x轴没有到左上角0 0的位置就进行重绘
        if (this.sx >= can.width){
            this.sx = can.width;
            this.sw = can.width;
        }else{


            this.sx = vx;
            this.sw = (750 - vx) - vx*(177/511);
            
            var scaW = this.sw / 62;

            console.log(scaW);
            


            // this.sw2 = 62 + vx +  vx*(177/511);
            this.sw2 = 750/scaW;
            this.sx2 = 750 - this.sw2 - (750 - this.sw2) * (177/688);
            // this.sx2 = 750 - this.sw2  ;
           
        }

        if (this.sy >= can.height){
            this.sy >= can.height;
            this.sh = can.height;
        }else{

            this.sy =  vy;

            this.sh = 1206 - vy  - vy*(468/638);

            var scaH = this.sh / 100;

            console.log(scaH);

            
            // this.sh2 = (100 + vy + vy * (468/638));
            this.sh2 = 1206 / scaH;
            this.sy2 = 1206 - this.sh2 - (1206 - this.sh2) *(468/1106) ;
            // this.sy2 = 1206 - this.sh2  ;
        }



        console.log('w: '+this.sw);
        console.log('h: '+this.sh);
        console.log('x: '+this.sx);
        console.log('y: '+this.sy);

        console.log('w2: '+this.sw2);
        console.log('h2: '+this.sh2);
        console.log('x2: '+this.sx2);
        console.log('y2: '+this.sy2);

        console.log(this.sw/this.sw2);

        this.draw();

    }

    var index = 0;
    // 算法需要的几个变量
    var start = 0;
    // during根据设置的总时间计算
    var during = 230;  //17ms每帧，100帧等于1700ms 
    // 动画请求帧
    var req = null;
    var time = 0;

    var render = function (obj) {
        console.log(obj);
        
        var vx = easeIn(start,0,511,during);
        var vy = easeIn(start,0,638,during);
        start++;
        console.log(start,vx,vy);
        if (vx <= 511){
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBack.call(obj,vx,vy);

            req = requestAnimationFrame(function(){
                render(obj)
            });
        }
        else{
            index++
            start = 0;
            console.log(index);
            if (index >= arr.length){
                return
            }
            cancelAnimationFrame(req);
            console.log(index);
            render(arr[index]);
            // console.log(1);
        }
    };


    var imgInfo1 = {
        imgUrl1:'1.jpg',
        imgUrl2:'2.jpg',

        // 大图片老奶奶的位置和宽高属性（小奶奶）
        sx : 0,
        sy : 0,
        sw : 750,
        sh : 1206,

        // 首页老奶奶的位置和宽高属性（大奶奶）
        sx2 : 511,
        sy2 : 638,
        sw2 : 62,
        sh2 : 100,
    }


    var drawImg1 = new drawScale(imgInfo1);

console.log(drawImg1);
    var arr = [drawImg1]
    // setInterval(function(){
    //     if (drawImg.sx == 0 || drawImg.sy == 0)
    //         return
    //     render()
    // },200)
    
   // render(drawImg1)

    $('.btn').on('touchstart',function(e){
        if (index >= arr.length){
                return
            }
        render(arr[index]);
        e.preventDefault();
       
    });


    $('.btn').on('touchend',function(){
        cancelAnimationFrame(req)
    });
        
    </script>
</body>
</html>